\section{Discusión}
Basándonos en las pruebas realizadas y corroborando más precisamente con \ref{tab:hresult}, podríamos inferir que el estimador propuesto por nuestro grupo es el candidato a ser elegido como el mejor de todos para todas los tipos de distribuciones. Esto último se debe a que el cálculo de la estimación, deja de ser ``estimada'' para pasar a ser exacta. Sin embargo, asegurar esto sería un error, dado que dicho estimador abusa de la posibilidad de  almacenar todos los elementos distintos en memoria. En el caso en que esto no pudiese garantizarse, no podría ser implementado. Por lo tanto, lo primero que podemos comentar es que en caso en que podamos hacer uso de la memoria para guardar los elementos no repetidos, definitivamente nustro estimador sería la mejor elección posible.\\
Igualmente sabemos que existen casos en los que no se podrá realizar tal acción y por eso que seguiremos hablando sobre las comparaciones detalladas entre las implementaciones de los estimadores presentes en el paper de Piatetsky-Shapiro. \\
Basándonos en nuestro análisis empírico podemos afirmar que ambas funcionan de manera satisfactoria para distribuciones del tipo uniformes y normales. Esto no debería ser ninguna sorpresa para nosotros, dado que ya fue explicado porqué debía pasar en la sección \textbf{3}. Sin embargo, un detalle que pudimos notar a partir de los resultados obtenidos es el comportamiento oscilatorio de las comparaciones por mayor, del estimador \textbf{Steps} una vez que el parámetro $p$ es mayor a 100. Esto, si bien no estaba adelantado / explicado en el marco teórico, tiene su justificación. Con fines de no repetir lo que ya se comentó, únicamente diremos que eso dicho problema de debe a que al agrandarse el parámetro $p$, la variable densidad se hace cada vez más chica logrando que varios extremos de los buckets coincidan. (Para información más precisa, sección: 2.2)  \\
Mirando \ref{tab:hresult}, podemos notar que el estimador \textbf{Classic} suele comportarse muy bien en \underline{TODAS} las distribuciones de las posibles columnas de la base otorgada por la cátedra cuando la consulta es por igualdad. No ocurre lo mismo cuando la consulta compara por mayor. De hecho ``invierte'' los papeles y parece que el que logra tener mejores resultados es el estimador \textbf{Steps}. Igualmente, dado que existen muchos empates en este caso (en la comparación entre los dos tipos de estimadores) creemos que no es ventaja significante, como sí lo es la diferencia que obtiene \textbf{Classic} en la comparación por igual. En definitiva, si tuviésemos que elegir uno de los dos para tomarlo como estimador ante una distribución no conocida, elegiríamos a \textbf{Classic}. \\
Como agregado, ambas tres implementaciones (y vuelvo a sumar a nuestro estimador), quizás tarden su tiempo en inicializarse, pero la idea es que cuando alguien realice una consulta a la base, éste tarde muy poco tiempo en devolver una respuesta que considere correcta. Es necesario que sea rápido dada que se hacen muchas consultas SQL por unidad de tiempo en un servidor. En cambio la creación de cero de un estimador, no es tan frecuente y es porque que podemos aprovechar ese tiempo para crearlo. 




